def knapsack(capacity, items):
from collections import defaultdict
memo = defaultdict(int)
for i in range(1, len(items) + 1):
weight, value = items[i - 1]
for j in range(1, capacity + 1):
memo[i, j] = memo[i - 1, j]
if weight <= j:
memo[i, j] = max(
memo[i, j],
value + memo[i - 1, j - weight]
)
return memo[len(items), capacity]


def kheapsort(arr, k):
import heapq
heap = arr[:k]
heapq.heapify(heap)
for x in arr[k:]:
yield heapq.heappushpop(heap, x)
while heap:
yield heapq.heappop(heap)

def shunting_yard(tokens):
precedence = {
'+': 1,
'-': 1,
'*': 2,
'/': 2
}

rpntokens = []
opstack = []
for token in tokens:
if isinstance(token, int):
rpntokens.append(token)
else:
while opstack and precedence[token] <= precedence[opstack[-1]]:
rpntokens.append(opstack.pop())
opstack.append(token)

while opstack:
rpntokens.append(opstack.pop())

return rpntokens

def lis(arr):
ends = {} 
longest = 0 

for i, val in enumerate(arr): 

prefix_lengths = [j for j in range(1, longest + 1) if arr[ends[j]] < val]

length = max(prefix_lengths) if prefix_lengths else 0

if length == longest or val < arr[ends[length + 1]]:
ends[length + 1] = i 
longest = max(longest, length + 1)

return longest

def powerset(arr):
if arr: 
first, *rest = arr 
rest_subsets = powerset(rest) 
return rest_subsets + [[first] + subset for subset in rest_subsets]
else: 
return [[]]

def shortest_paths(source, weight_by_edge):
weight_by_node = {
v: float('inf') for u, v in weight_by_edge
}
weight_by_node[source] = 0

for i in range(len(weight_by_node) - 1):
for (u, v), weight in weight_by_edge.items():
weight_by_node[v] = min(
weight_by_node[u] + weight,
weight_by_node[v]
)
return weight_by_node
